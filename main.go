package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"
)

func main() {
	log.SetFlags(log.Lshortfile)
	
	directory := "embed"
	filename := "embed.go"
	packageName := "main"

	files := filesToEmbed(directory)

	embed, err := os.Create(filename)
	if err != nil {
		log.Fatalln(err)
	}
	defer embed.Close()

	fmt.Fprintf(embed, "package %s\n\n", packageName)
	fmt.Fprintf(embed, "// Automatically generated by github.com/nathankerr/embed\n\n")
	fmt.Fprintf(embed, "import \"time\"\n\n")
	fmt.Fprintf(embed, "type embedded map[string]string\n")
	fmt.Fprintf(embed, "var embed embedded\n")
	fmt.Fprintf(embed, "var embeddedTime time.Time\n\n")

	fmt.Fprintf(embed, "func init() {\n")
	fmt.Fprintf(embed, "\tembed = make(embedded)\n")
	fmt.Fprintf(embed, "\tvar err error\n")
	fmt.Fprintf(embed, "\tembeddedTime, err = time.Parse(time.RFC1123, %#v)\n", time.Now().Format(time.RFC1123))
	fmt.Fprintf(embed, "\tif err != nil {\n\t\tpanic(err)\n\t}\n\n")
	for _, file := range files {
		path := filepath.Join(directory, filepath.FromSlash(file))
		fmt.Printf("embed[\"%s\"]\n", file)

		contents, err := ioutil.ReadFile(path)
		if err != nil {
			log.Fatalln(err)
		}

		fmt.Fprintf(embed, "\tembed[\"%s\"] = %#v\n", file, string(contents))
	}
	fmt.Fprintf(embed, "}\n")
}

// returns the complete list of files in all directories
// under path. File names are relative to path.
func filesToEmbed(path string) []string {
	toSearch := []string{path}
	toEmbed := []string{}

	for i := 0; i < len(toSearch); i++ {
		directory := toSearch[i]

		files, directories := list(directory)

		for _, dir := range directories {
			toSearch = append(toSearch, filepath.Join(directory, dir))
		}

		embedPath := strings.Join(strings.Split(filepath.ToSlash(directory), "/")[1:], "/")
		if len(embedPath) != 0 {
			embedPath += "/"
		}

		for _, file := range files {
			toEmbed = append(toEmbed, embedPath + file)
		}
	}

	return toEmbed
}

// read directory
// returns list of normal files and list of directories
func list(path string) (files []string, directories []string) {
	files = []string{}
	directories = []string{}

	dir, err := os.Open(path)
	if err != nil {
		log.Fatalln(err)
	}
	defer dir.Close()

	names, err := dir.Readdirnames(-1)
	if err != nil {
		log.Fatalln(err)
	}

	for _, name := range names {
		if isDir(filepath.Join(path, name)) {
			directories = append(directories, name)
		} else {
			files = append(files, name)
		}
	}

	return files, directories
}

// determines if the given path is a directory
func isDir(path string) bool {
	file, err := os.Open(path)
	if err != nil {
		log.Fatalln(err)
	}
	defer file.Close()

	info, err := file.Stat()
	if err != nil {
		log.Fatalln(err)
	}

	return info.IsDir()
}
